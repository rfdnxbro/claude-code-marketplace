# AI駆動開発ライフサイクル（AI-DLC）方法論定義

> **編集禁止**
>
> 本ドキュメントは原典ホワイトペーパーの忠実な翻訳であり、編集してはいけません。
> このファイルへの変更は参考資料としての整合性を損ないます。

> **著作権表示**
>
> 本ドキュメントは Amazon Web Services の Raja SP 氏による著作物の日本語訳です。
> このプラグインでは、AI-DLC方法論の参考資料として保管しています。
>
> 原著者: Raja SP, Amazon Web Services
> 原典: <https://prod.d13rzhkk8cj2z0.amplifyapp.com/>

---

Raja SP, Amazon Web Services

## I. 背景

ソフトウェアエンジニアリングの進化は、低レベルで差別化されないタスクを抽象化することで、開発者が複雑な問題の解決に集中できるようにするための継続的な探求でした。初期の機械語から高水準プログラミング言語、APIやライブラリの採用まで、各ステップは開発者の生産性を大幅に向上させてきました。現在、大規模言語モデルの統合により、コード生成、バグ検出、テスト生成などのタスクに対話的な自然言語インタラクションが導入され、ソフトウェアの作成方法に革命が起きています。これがAI支援時代の幕開けであり、AIがこのような細かい特定のタスクを強化しています。

AIが進化するにつれ、その応用はコード生成を超えて、要件の詳細化、計画、タスク分解、設計、開発者とのリアルタイムコラボレーションへと拡大しています。この変化がAI駆動時代の始まりであり、AIが開発プロセスを積極的にオーケストレーションします。しかし、人間主導の長期プロセス向けに設計された既存のソフトウェア開発手法は、AIの速度、柔軟性、高度な機能（例：エージェント的）と完全には整合していません。手動ワークフローや硬直した役割定義への依存が、AIを十分に活用する能力を制限しています。これらの手法にAIを後付けすることは、その可能性を制限するだけでなく、時代遅れの非効率性を強化してしまいます。AIの変革力を十分に活用するには、SDLC手法を再構想する必要があります。この再構想には、AIを中心的な協力者として位置づけ、ワークフロー、役割、イテレーションを調整して、より迅速な意思決定、シームレスなタスク実行、継続的な適応性を可能にする必要があります。

本論文では、AIの機能を完全に統合するために再構想されたAIネイティブな方法論であるAI駆動開発ライフサイクル（AI-DLC）を紹介・定義し、ソフトウェアエンジニアリングの次の進化の基盤を築きます。

## II. 主要原則

このセクションの原則は、AI-DLCを定義するための基盤を形成し、そのフェーズ、役割、成果物、リチュアルを形作ります。これらの前提は、提案された方法を検証するために重要であり、その設計の根拠を提供します。

### 1. 後付けではなく再構想

SDLCやアジャイル（例：スクラム）などの既存の手法を維持してAIを後付けするのではなく、開発手法を再構想することを選択します。これらの従来の手法は、より長いイテレーション期間（月や週）向けに構築されており、デイリースタンドアップやレトロスペクティブなどのリチュアルにつながりました。対照的に、AIの適切な適用は、時間や日単位で測定される迅速なサイクルにつながります。これには継続的でリアルタイムの検証とフィードバックメカニズムが必要であり、従来のリチュアルの多くはあまり関連性がなくなります。AIが簡単、中程度、難しいタスクの境界を薄める場合、工数見積り（例：ストーリーポイント）はそれほど重要でしょうか？ベロシティのような指標は関連性があるのでしょうか、それとも例えばビジネス価値に置き換え始めるべきでしょうか？また、AIは計画、タスク分解、要件分析、設計技法の適用（例：ドメインモデリング）を含む手動プラクティスを自動化するように進化しており、意図からコードに移行するまでのフェーズ数を短縮しています。これらの新しいダイナミクスは、後付けではなく、第一原理思考に基づく再構想を必要とします。私たちが必要としているのは自動車であり、より速い馬車ではありません。

### 2. 会話の方向を逆転

AI-DLCは、人間がAIとの会話を開始してタスクを完了するのではなく、AIが会話を開始し主導するという根本的な転換を導入します。AIは、高レベルの意図（例：新しいビジネス機能の実装）を実行可能なタスクに分解し、推奨事項を生成し、トレードオフを提案することでワークフローを駆動します。人間は承認者として機能し、重要な局面で検証、オプションの選択、決定の確認を行います。このAI駆動アプローチにより、開発者はAIが計画、タスク分解、自動化を処理する間、高価値の意思決定に集中できます。従来のダイナミクスを逆転させることで、AI-DLCは人間の関与が目的を持ち、監視、リスク軽減、戦略的整合に集中することを保証し、速度と品質の両方を向上させます。これを説明する例えとしてGoogleマップがあります：人間が目的地（意図）を設定し、システムがステップバイステップの道順（AIのタスク分解と推奨）を提供します。途中で、人間は監視を維持し、必要に応じて旅を調整します。

### 3. 設計技法のコアへの統合

スクラムやカンバンなどのアジャイルフレームワークは、設計技法（例：ドメイン駆動設計）を範囲外とし、チームが独自に選択することを推奨しています。これにより、全体的にソフトウェア品質の低下につながる重要な空白が残されました。米国だけでソフトウェア品質問題は2022年に2.41兆ドルのコストがかかると推定されました（調査）。設計技法を切り離すのではなく、AI-DLCはそれらを不可欠なコアとして持ちます。ドメイン駆動設計（DDD）、振る舞い駆動開発（BDD）、またはテスト駆動開発（TDD）をそれぞれ採用するチーム向けに、AI-DLCの異なるフレーバーがあります。本論文では、DDDの原則を使用してシステムを独立した適切なサイズの境界づけられたコンテキストに分解し、並行して迅速に構築できるAI-DLCのDDDフレーバーについて説明します。AIは計画とタスク分解中にこれらの技法を本質的に適用し、開発者は検証と調整のみを行います。この統合は、手動の重労働を排除しながらソフトウェア品質を維持し、時間または日単位のイテレーションサイクルを可能にする鍵です（「より良いシステムをより速く構築する」というマントラ）。

### 4. AI能力との整合

本論文はAIの将来の可能性について楽観的ですが、現在の状態については完全に現実的です。AI-DLCは、現在のAIは進歩しているものの、解釈可能性と安全性を確保しながら、高レベルの意図を実行可能なコードに自律的に変換したり、人間の監視なしに独立して動作したりすることにはまだ信頼性がないことを認識しています。同時に、開発者が知的重労働の大部分を行い、AIが単に拡張を提供するAI支援パラダイムは、開発におけるAIの完全な可能性を解放できません。AI-DLCは、現在のAIの能力と限界と人間の関与のバランスを取るAI駆動パラダイムを採用します。このパラダイムでは、開発者は検証、意思決定、監視の最終責任を保持します。このバランスにより、開発者の判断が提供する重要なセーフガードを損なうことなく、AIの強みが効果的に活用されます。

### 5. 複雑なシステム構築への対応

AI-DLCは、継続的な機能適応性、高いアーキテクチャの複雑さ、多数のトレードオフ管理、スケーラビリティ、統合およびカスタマイズ要件を必要とするシステムの構築に対応します。これらは、高度な設計技法、パターン、ベストプラクティスの適用を必要とし、通常、大規模および/または規制された組織内で複数のチームが一体となって作業することを伴います。トレードオフ管理がほとんどまたはまったく必要ない非開発者ペルソナによって開発できるシンプルなシステムは、AI-DLCの範囲外であり、ローコード/ノーコードアプローチに適しています。

### 6. 人間との共生を強化するものを保持

手法を再構想する一方で、人間の検証とリスク軽減に重要な既存の手法からの成果物とタッチポイントを保持します。例えば、ユーザーストーリーは、構築すべきものについて人間とAIの理解を一致させ、明確に定義された契約として機能します。再構想された手法でもユーザーストーリーをそのまま保持します。もう一つの例は、AI生成の計画とコードが組織のリスクフレームワークに準拠することを保証するリスクレジスターです。これらの保持された要素は、整合性や安全性を損なうことなく迅速なイテレーションを可能にするために、リアルタイム使用に最適化されます。

### 7. 親しみやすさによる移行の促進

新しい手法は広範なトレーニングを必要とせず、既存の実践者は1日でオリエンテーションを受けて実践を開始できる必要があります。連想学習による採用を容易にするために、AI-DLCは古い手法の馴染みのある用語間の基本的な関係を保持しながら、現代化された用語を導入します。例えば、スクラムのスプリントは構築と検証のためのイテレーションサイクルを表します。しかし、スプリントは通常、AI以前の時代には4〜6週間の長さでした。AI-DLCでは、イテレーションサイクルは継続的で、時間または日単位です。したがって、スプリントを意図的に改名する必要があります。AI-DLCはスプリントをボルトに改名し、前例のない速度を提供する迅速で集中的なサイクルを強調します。

### 8. 効率化のための責任の合理化

AIのタスク分解と意思決定を実行する能力を活用することで、開発者はインフラストラクチャ、フロントエンド、バックエンド、DevOps、セキュリティなどの従来の専門分野のサイロを超越できるようになります。この責任の収束により、複数の専門的な役割の必要性が減少し、開発プロセスが合理化されます。しかし、プロダクトオーナーと開発者はフレームワークの不可欠な部分であり続け、監視、検証、戦略的意思決定の重要な責任を保持します。これらの役割は、ビジネス目標との整合を確保し、設計品質を維持し、リスク管理フレームワークへの準拠を維持し、自動化と人間の責任のバランスを保ちます。手法の定義では、第一原理に従い、役割を最小限に保ち、重要な場合にのみ追加の役割を導入します。

### 9. ステージを最小化し、フローを最大化

自動化と責任の収束により、AI-DLCはハンドオフと移行を最小化し、継続的な反復フローを可能にすることを目指します。しかし、AI生成のコードが硬直化（「急速セメント」）せず、将来のイテレーションに適応可能であることを確保するために、人間の検証と意思決定は引き続き重要です。これに対処するために、AI-DLCは重要な意思決定の局面で人間の監視のために特別に設計された最小限でありながら十分な数のフェーズを組み込んでいます。これらの検証は、無駄な下流の努力が発生する前にそれらを特定し削減することで、「損失関数」の形式として機能します。

### 10. 硬直した意見付きのSDLCワークフローなし

AI-DLCは、異なる開発パスウェイ（新システム開発、リファクタリング、欠陥修正、マイクロサービスのスケーリングなど）に対して意見付きのワークフローを規定することを避けます。代わりに、与えられたパスウェイの意図に基づいてAIがレベル1プランを推奨する、真にAIファーストのアプローチを採用します。人間はAIとの対話的な対話を通じてこれらのAI生成プランを検証し調整し、レベル2（サブタスク）および後続の階層レベルを通じてこのプロセスを続けます。タスク実行レベルでは、AIがタスクを実装し、人間は結果の検証と検証を通じて監視を維持します。この柔軟なアプローチにより、方法論は適応可能であり、重要な決定に対する人間のコントロールを維持しながら、AI機能とともに進化できます。

## III. コアフレームワーク

このセクションでは、AI-DLCのコアフレームワークを概説し、そのフェーズ、役割、ワークフロー、主要な成果物を詳述します。

### 1. 成果物

AI-DLCにおける**インテント**は、ビジネス目標、機能、または技術的成果（例：パフォーマンススケーリング）のいずれであっても、達成すべきことをカプセル化する高レベルの目的の声明です。これは、AI駆動の分解の開始点として機能し、人間の目標をAI生成のプランと整合させます。

**ユニット**は、インテントから派生した、測定可能な価値を提供するために特別に設計された、凝集性のある自己完結型の作業要素を表します。例えば、ビジネスアイデアを実装するインテントは、DDDのサブドメインやスクラムのエピックに類似した独立した機能ブロックを表すユニットに分解される場合があります。各ユニットは、その機能範囲を明確にするタスクのセット（この場合はユーザーストーリー）を包含します。AI-DLCのコンテキストでは、インテントをユニットに分解するプロセスはAIによって駆動され、開発者および/またはプロダクトオーナーが結果のユニットを検証し、ビジネスおよび技術目標との整合を確保するために洗練します。ユニットは疎結合であり、下流での自律的な開発と独立したデプロイを可能にします。

**ボルト**はAI-DLCにおける最小のイテレーションであり、ユニットまたはユニット内のタスクセットの迅速な実装のために設計されています。ボルト（スクラムのスプリントに類似）は、集中的なフォーカスと高速デリバリーを強調し、ビルド検証サイクルは週ではなく時間または日単位で測定されます。各ボルトは、明確に定義された作業範囲（例：ユニット内のユーザーストーリーのコレクション）をカプセル化し、サポートするユニットの全体的な目標との整合を維持しながら、段階的な進歩を可能にします。ユニットは、並行してまたは順次に実行される1つ以上のボルトを通じて実行できます。AIは開発者/プロダクトオーナーが検証するボルトを計画します。

**ドメイン設計**成果物は、インフラストラクチャコンポーネントとは独立して、ユニットのコアビジネスロジックをモデル化します。AI-DLCの最初のバージョンでは、AIはドメイン駆動設計の原則を使用して、集約、値オブジェクト、エンティティ、ドメインイベント、リポジトリ、ファクトリを含む戦略的および戦術的モデリング要素を作成します。**論理設計**は、適切なアーキテクチャ設計パターン（例：CQRS、サーキットブレーカーなど）の選択を使用して、非機能要件を満たすためにドメイン設計を拡張して変換します。AIは開発者による検証のためにアーキテクチャ決定レコード（ADR）を作成します。論理設計仕様により、AIは適切なAWSサービスとコンストラクトを選択することでウェルアーキテクトの原則に準拠しながら、コードとユニットテストを生成します。この段階で、AIエージェントはユニットテストを実施し、結果を分析し、開発者に修正の推奨を提供します。

**デプロイメントユニット**は、パッケージ化された実行可能コード（例：Kubernetes環境用のコンテナイメージ、AWS Lambdaなどのサーバーレス関数）、構成（例：Helmチャート）、および機能受け入れ、セキュリティ、NFR、その他のリスクについてテストされたインフラストラクチャコンポーネント（例：TerraformまたはCFNスタック）を包含する運用成果物です。AIは、機能テスト、静的および動的セキュリティテスト、負荷テストシナリオを含むすべての関連テストを生成します。テストシナリオとケースに対する人間の検証と調整の後、AIエージェントはテストスイートを実行し、結果を分析し、障害点をコード変更、構成、またはその他の依存関係と相関させます。したがって、これらのユニットは、機能受け入れ、セキュリティコンプライアンス、非機能要件（NFR）への準拠、運用リスクの軽減について厳密にテストされ、シームレスなデプロイの準備を保証します。

### 2. フェーズとリチュアル

**インセプションフェーズ**は、インテントをキャプチャし、開発のためにユニットに変換することに焦点を当てます。このフェーズでは、共同要件詳細化と分解リチュアルである「モブエラボレーション」を使用します。これは、ファシリテーターが主導する共有スクリーンを備えた単一の部屋で行われます。モブエラボレーション中、AIはインテントをユーザーストーリー、受け入れ基準、ユニットに分解する初期提案において中心的な役割を果たし、ドメイン知識と、下流での迅速な並列実行のための疎結合と高凝集の原則を活用します。プロダクトオーナー、開発者、QA、およびその他の関連するステークホルダー（モブ）は、過少設計または過剰設計された部分を調整し、現実世界の制約と整合させることで、これらのAI生成成果物を共同でレビューし洗練します。このフェーズの出力には、明確に定義されたユニットとそれぞれのコンポーネントが含まれ、a) PRFAQ、b) ユーザーストーリー、c) 非機能要件（NFR）定義、d) リスクの説明（組織のリスクレジスターと一致する場合）、e) ビジネスインテントにトレースするメジャメント基準、およびf) ユニットを構築するための推奨ボルトが含まれます。モブエラボレーションは、数週間または数ヶ月のシーケンシャルな作業を数時間に凝縮しながら、モブ内およびモブとAI間の深い整合を達成します。

**コンストラクションフェーズ**は、タスクの反復的な実行を包含し、インセプションフェーズで定義されたユニットをテスト済みの運用準備完了デプロイメントユニットに変換します。このフェーズは、AIが技術的考慮事項とは独立してビジネスロジックをモデル化するドメイン設計から、非機能要件と適切なクラウド設計パターンが適用される論理設計へと進行します。AIは論理設計からコンポーネントを適切なAWSサービスにマッピングしながら、ウェルアーキテクトの原則に準拠して詳細なコードを生成します。フェーズは、機能、セキュリティ、運用準備を確保するための自動テストで終了します。開発者は、各ステップでAI生成出力を検証し、重要な決定を行うことに焦点を当て、各イテレーションで品質と適応性を確保します。ブラウンフィールド（既存のアプリケーション）シナリオでは、コンストラクションフェーズは最初にコードをセマンティックに豊富なモデリング表現にエレベートすることを含み、AIへのコンテキストが簡潔で正確になります。推奨されるモデリング表現は、静的モデル（ドメインコンポーネント、責任、およびそれらの関係のみ）と動的モデル（コンポーネントが重要なユースケースを実現するためにどのように相互作用するか）です。

AIはこのフェーズを通じて中心的な役割を果たし、各タスクでタスクを推奨し、オプション（設計パターン、ユーザーエクスペリエンス、テストなど）を提供します。AI-DLCは、モブエラボレーションと同様に、すべてのチームが単一の部屋にコロケーションして行うことを推奨しています。チームは統合仕様（ドメインモデル段階から）を交換し、決定を下し、ボルトを提供します。AI-DLCはこれを**モブコンストラクション**リチュアルと呼びます。

AI-DLCにおける**オペレーションフェーズ**は、AIを活用した運用効率のためにシステムのデプロイ、オブザーバビリティ、メンテナンスを中心としています。AIはメトリクス、ログ、トレースを含むテレメトリデータを積極的に分析し、パターンを検出し、異常を特定し、潜在的なSLA違反を予測して、プロアクティブな問題解決を可能にします。さらに、AIは事前定義されたインシデントランブックと統合し、リソーススケーリング、パフォーマンスチューニング、障害分離などの実行可能な推奨を提案し、開発者によって承認された場合に解決を実行します。開発者は検証者として機能し、AI生成のインサイトと提案されたアクションがSLAとコンプライアンス要件に整合することを確保します。

### 3. ワークフロー

ビジネスインテント（例：グリーンフィールド開発、ブラウンフィールド強化、モダナイゼーション、または欠陥修正）が与えられると、AI-DLCはインテントを実装するワークフローを概説するレベル1プランを生成するようAIに促すことから始まります。このプランは初期提案として機能し、その後、ビジネス目標とエンジニアリング制約との整合を確保するために人間によって透明にレビュー、検証、洗練されます。AI-DLCの核心は、各ステップの成果物を段階的に豊かにするために人間の監視を適用し、それらを次のステップのためのセマンティックに豊富なコンテキストに変換する原則です。各ステップは戦略的な意思決定ポイントとして機能し、人間の監視は損失関数のように機能します - 下流で雪だるま式に増える前にエラーを早期にキャッチして修正します。これは再帰的に繰り返されます。レベル1プランの各ステップは、AIによってより細かい粒度の実行可能なサブタスクにさらに分解され、再び人間の監視の下で正確性とコンテキストの適切性が確保されます。

生成されたすべての成果物（インテント、ユーザーストーリー、ドメインモデル、またはテストプラン）は永続化され、AIがライフサイクル全体で参照する「コンテキストメモリ」として機能します。従来のSDLC手法と同様に、AI-DLCは本質的に反復的であり、継続的な洗練と適応を可能にします。さらに、すべての成果物はリンクされており、前後のトレーサビリティを可能にし（例：ドメインモデル要素を特定のユーザーストーリーに接続）、AIが各段階で正しい最も関連性のあるコンテキストを取得することを保証します。プロセス全体を通じて、AIは戦略的計画、タスク分解、生成などを実行し、人間は監視と検証を提供します。

## IV. AI-DLCの実践：グリーンフィールド開発

プロダクトオーナーが「クロスセル製品のレコメンデーションエンジンを開発する」などの高レベルのインテントを明確にすることでプロセスを開始するシナリオを検討します。AIはこれを新しいアプリケーションを構築するインテントとして認識し、上記のセクションのワークフローステップのようなレベル1プランを生成します。チームはレベル1プランのステージを検証、確認し、追加/修正します。最終化されたレベル1プランで、AIはインセプションフェーズに進みます。AIとの対話と監視を提供する方法として、付録Aのプロンプトを参照してください。

### 1. インセプションフェーズ

以下の箇条書きは、モブエラボレーションリチュアルの主要なインタラクションを概説しています。

a. AIは明確化の質問をします（例：「主要なユーザーは誰ですか？このプロジェクトが達成すべき主要なビジネス成果は何ですか？」）、目標の包括的な理解を確保し、元の意図の曖昧さを最小化します

b. AIは明確化された意図をユーザーストーリー、非機能要件（NFR）、およびリスク説明に詳細化します。チームはこれらの成果物を検証し、監視を提供し、AIに必要な修正を行います。

c. AIは高度に凝集したストーリーをユニットに構成します。例：「ユーザーデータ収集」、「レコメンデーションアルゴリズム選択」、「API統合」。

d. プロダクトオーナーはこれらの出力を検証し、ユニットを洗練するために必要に応じて調整します。例：プロダクトオーナーはユーザーデータ収集にプライバシーコンプライアンスの詳細が不足していることに気づき、GDPR固有の考慮事項を含むように要件を調整します。

e. AIはモジュールのPRFAQを生成します（オプション）、ビジネスインテント、機能、および期待される利点を要約します。

f. 開発者とプロダクトオーナーはPRFAQと関連するリスクを検証し、全体的な目標との整合を確保します。

### 2. コンストラクションフェーズ

以下の箇条書きは、このフェーズに関わる主要な活動を概説し、モブプログラミングとモブテストリチュアルに焦点を当てています。

a. 開発者はAIとのセッションを確立します。AIは開発者に割り当てられたユニットから始めるよう促します。

b. AIはドメイン駆動設計の原則を使用して、割り当てられたユニットのコアビジネスロジックをモデル化します。例：「レコメンデーションアルゴリズム」ユニットでは、AIはProduct、Customer、Purchase Historyなどの関連エンティティとそれらの関係を特定します。

c. 開発者はドメインモデルをレビューおよび検証し、ビジネスロジックを洗練し、現実世界のシナリオとの整合を確保します（例：新規顧客の購入履歴がない場合の処理方法）

d. AIはドメインモデルを論理設計に変換し、スケーラビリティやフォールトトレランスなどのNFRを適用します。例：AIはアーキテクチャパターン（例：イベント駆動設計）と技術（例：サーバーレスコンピューティング用のAWS Lambda）を推奨します。

e. 開発者はAIの推奨を評価し、トレードオフを承認し、必要に応じて追加の考慮事項を提案します。（例：スケーラビリティのためにLambdaを受け入れますが、より高速なクエリパフォーマンスのためにストレージをDynamoDBにオーバーライドします）

f. AIは各ユニットの実行可能なコードを生成し、論理コンポーネントを特定のAWSサービスにマッピングします。

g. また、機能、セキュリティ、パフォーマンステストも自動生成します（例：「レコメンデーションアルゴリズム」ユニットでは、AIは協調フィルタリングを実装するコードを作成し、DynamoDBデータソースと統合します）

h. 開発者は生成されたコードとテストシナリオ/ケースをレビューし、品質とコンプライアンスを確保するために必要に応じて調整します。

**テストと検証：**

a. AIはすべてのテスト（機能、セキュリティ、パフォーマンス）を実行し、結果を分析し、問題を強調表示します。

b. 失敗したテストの修正を提案します。例：より良いパフォーマンスのためにクエリロジックを最適化します。

c. 開発者はAIの発見を検証し、修正を承認し、必要に応じてテストを再実行します。

### 3. オペレーションフェーズ

**デプロイメント：**

a. AIはモジュールをデプロイメントユニット（例：コンテナイメージ、サーバーレス関数）にパッケージ化します。

b. 開発者はデプロイメント構成を承認し、ステージングおよび本番環境へのロールアウトを開始します。

**オブザーバビリティと監視：**

a. AIはメトリクス、ログ、トレースを分析して異常を特定し、潜在的なSLA違反を予測します。例：AIはピーク使用時のレイテンシスパイクを検出し、増加したトラフィックを処理するためにレコメンデーションエンジンをスケーリングすることを提案します。

b. AIはプレイブックと統合して運用問題に対するアクションを提案します。APIレスポンスタイムが低下した場合、AIはDynamoDBスループットの増加またはAPI Gatewayトラフィックのリバランスを推奨します。

c. 開発者はAIの推奨を検証し、軽減策を承認し、解決結果を監視します。

## V. AI-DLCの実践：ブラウンフィールド開発

ブラウンフィールドとは、新機能の追加、非機能要件の最適化、またはリファクタリングや欠陥修正を含む技術的負債の修正に関して、既存のシステムに変更を加えることを指します。このコンテキストでは、プロダクトマネージャーが既存のアプリケーションに新機能を追加する必要があるシナリオを検討します。

### 1. インセプションフェーズ

ブラウンフィールドにおけるインセプションフェーズの活動は、グリーンフィールドと同じです。

### 2. コンストラクションフェーズ

a. AIはコードをより高レベルのモデリング表現にエレベートします。モデルは静的モデル（コンポーネント、説明、責任、関係）と動的モデル（最も重要なユースケースを実現するためにコンポーネントがどのように相互作用するか）で構成されます

b. 開発者はプロダクトマネージャーと協力して、AIによってリバースエンジニアリングされた静的および動的モデルをレビュー、検証、修正します。

c. これらの追加ステップにより、コンストラクションフェーズの残りはグリーンフィールドシナリオと同様です。

### 3. オペレーションフェーズ

ブラウンフィールドにおけるオペレーションフェーズの活動は、グリーンフィールドと同じです。

## VI. AI-DLCの採用

AI-DLCは既存のアジャイル手法からあまり逸脱しておらず、採用の容易さを主要な成果として設計されています。それでも、従来の手法を長く実践している組織や、AIネイティブ手法の独自のバリエーションを発明しているプロセスにある組織は、AI-DLCを採用するための特定の戦略が必要です。以下の2つのアプローチがこれを容易にすると考えています。

a. **実践による学習** – AI-DLCは実際にはグループとして実践できるリチュアル（モブエラボレーション、モブコンストラクションなど）のセットです。ドキュメントや従来のトレーニングを通じて手法を学ぶのではなく、実践者が現在解決している複数の現実世界のシナリオでAI-DLCガイドとリチュアルを実践させます。AWSソリューションアーキテクトは、大規模組織での採用をハイパースケーリングするためにこのアプローチをパッケージ化したAI-DLC Unicorn Gymというフィールドオファリングを作成しました。

b. **新しい開発者エクスペリエンスツールへのAI-DLCの埋め込み** – 当社の顧客は、SDLCを横断して開発者に統一されたエクスペリエンスを提供する独自のオーケストレーションツールを構築しています。（例：CognizantのFlowSource、AspireのCodeSpell、HCLのAIForceなど）これらのツールにAI-DLCを埋め込むことで、大規模組織の開発者は大規模な採用活動を必要とせずにAI-DLCをシームレスに実践できます。

## 付録A

以下のプロンプトは、AI-DLCを実践するためにAIと対話するために使用できます。

### セットアッププロンプト

今日、アプリケーションの構築に取り組みます。すべてのフロントエンドとバックエンドコンポーネントについて、プロジェクトフォルダを作成します。すべてのドキュメントはaidlc-docsフォルダに格納されます。セッションを通じて、作業の計画を立て、計画用のmdファイルを作成するよう求めます。私が承認した後にのみ作業を進めることができます。これらの計画は常にaidlc-docs/plansフォルダに保存されます。md形式で多くの種類のドキュメントを作成します。要件、機能変更ドキュメントはaidlc-docs/requirementsフォルダに格納されます。ユーザーストーリーはaidlc-docs/story-artifactsフォルダに保存する必要があります。アーキテクチャと設計ドキュメントはaidlc-docs/design-artifactsフォルダに保存する必要があります。すべてのプロンプトは順序どおりにaidlc-docs/prompts.mdファイルに保存されます。このプロンプトの理解を確認してください。まだ存在しない場合は、保存に必要なフォルダとファイルを作成してください。

### インセプション

#### ユーザーストーリー

あなたの役割：あなたは経験豊富なプロダクトマネージャーであり、以下のタスクセクションで説明されているシステムを開発するための契約となる明確に定義されたユーザーストーリーを作成する任務を負っています。先の作業を計画し、計画の各ステップにチェックボックス付きでmdファイル（user_stories_plan.md）にステップを書いてください。いずれかのステップで私の確認が必要な場合は、確認を得るためにステップにメモを追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

あなたのタスク：ここで説明されている高レベルの要件に対してユーザーストーリーを作成します << 製品説明を記述 >>

<<<計画をレビューして変更した後>>>>

はい、<<mdファイル>>の計画が気に入りました。今、その計画を正確に従ってください。計画で指定されているように私と対話してください。各ステップを終えたら、計画のチェックボックスをマークしてください。

#### ユニット

あなたの役割：あなたは経験豊富なソフトウェアアーキテクトです。以下のタスクを開始する前に、計画を立て、計画の各ステップに対してチェックボックス付きでunits_plan.mdファイルにステップを書いてください。いずれかのステップで私の確認が必要な場合は、私と対話して確認を得るためにステップに追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

あなたのタスク：mvp_user_stories.mdファイルのユーザーストーリーを参照してください。ユーザーストーリーを独立して構築できる複数のユニットにグループ化してください。各ユニットには、単一のチームで構築できる高度に凝集したユーザーストーリーが含まれています。ユニットは互いに疎結合です。各ユニットについて、それぞれのユーザーストーリーと受け入れ基準をdesign/フォルダ内の個別のmdファイルに書いてください。

<<<計画をレビューして変更した後>

承認します。続行してください。

### コンストラクション

#### ドメイン（コンポーネント）モデル作成

あなたの役割：あなたは経験豊富なソフトウェアエンジニアです。以下のタスクを開始する前に、計画を立て、計画の各ステップに対してチェックボックス付きでdesign/component_model.mdファイルにステップを書いてください。いずれかのステップで私の確認が必要な場合は、私と対話して確認を得るためにステップに追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

あなたのタスク：design/seo_optimization_unit.mdファイルのユーザーストーリーを参照してください。すべてのユーザーストーリーを実装するためのコンポーネントモデルを設計してください。このモデルには、すべてのコンポーネント、属性、動作、およびユーザーストーリーを実装するためにコンポーネントがどのように相互作用するかが含まれている必要があります。まだコードは生成しないでください。コンポーネントモデルを/designフォルダ内の別のmdファイルに書いてください。

<<<計画をレビューして変更した後>>>>

計画を承認します。続行してください。各ステップを完了したら、計画ファイルのチェックボックスをマークしてください。

#### コード生成

あなたの役割：あなたは経験豊富なソフトウェアエンジニアです。以下のタスクを開始する前に、計画を立て、計画の各ステップに対してチェックボックス付きでmdファイルにステップを書いてください。いずれかのステップで私の確認が必要な場合は、私と対話して確認を得るためにステップに追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

タスク：search_discovery/nlp_component.mdファイルのコンポーネント設計を参照してください。設計にある自然言語処理（NLP）コンポーネントの非常にシンプルで直感的なPython実装を生成してください。processQuery(queryText)メソッドでは、amazon bedrock APIを使用してクエリテキストからエンティティを抽出してください。クラスをそれぞれ個別のファイルに生成しますが、`vocabMapper`ディレクトリに保持してください。

vocabMapperディレクトリに生成されたコードを参照してください。EntityExtractorコンポーネントがGenAIを呼び出すようにしたいです。現在の実装はローカルのvocabulary_repositoryを使用しています。エンティティ抽出とインテント抽出の両方にGenAIを活用する方法について分析し、計画を提示してください。

#### アーキテクチャ

あなたの役割：あなたは経験豊富なクラウドアーキテクトです。以下のタスクを開始する前に、計画を立て、計画の各ステップに対してチェックボックス付きでdeployment_plan.mdファイルにステップを書いてください。いずれかのステップで私の確認が必要な場合は、私と対話して確認を得るためにステップに追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

タスク：コンポーネント設計モデルdesign/core_component_model.md、UNITS/フォルダ内のユニット、ARCHITECTURE/フォルダ内のクラウドアーキテクチャ、BACKEND/フォルダ内のバックエンドコードを参照してください。以下を完了してください：

- [CloudFormation, CDK, Terraform]を使用してAWSクラウドへのバックエンドのデプロイに関するエンドツーエンドの計画を生成してください。
- デプロイの前提条件があれば、すべてドキュメント化してください。

計画を承認したら：

- クリーン、シンプル、説明可能なコーディングのベストプラクティスに従ってください。
- すべての出力コードはDEPLOYMENT/フォルダに格納されます。
- 生成されたコードが意図したとおりに動作することを検証するために、検証計画を作成し、検証レポートを生成してください。
- 検証レポートをレビューし、特定されたすべての問題を修正し、検証レポートを更新してください。

#### IaC/Rest APIの構築

あなたの役割：あなたは経験豊富なソフトウェアエンジニアです。以下のタスクを開始する前に、計画を立て、計画の各ステップに対してチェックボックス付きでmdファイルにステップを書いてください。いずれかのステップで私の確認が必要な場合は、私と対話して確認を得るためにステップに追加してください。重要な決定を独自に行わないでください。計画が完成したら、私のレビューと承認を求めてください。承認後、同じ計画を一度に1ステップずつ実行できます。各ステップを終えたら、計画のチェックボックスを完了としてマークしてください。

タスク：construction/<>/フォルダ内のservices.pyを参照してください。そこにある各サービスに対してPython Flask APIを作成してください。
